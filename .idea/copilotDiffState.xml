<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/chatbot_diseo/presentation/chat/ChatScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/chatbot_diseo/presentation/chat/ChatScreen.kt" />
              <option name="originalContent" value="package com.example.chatbot_diseo.presentation.chat&#10;&#10;import android.util.Log&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.lazy.rememberLazyListState&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import com.example.chatbot_diseo.presentation.menu.SideMenu&#10;&#10;@Composable&#10;fun ChatScreen(&#10;    navController: NavHostController,&#10;    initialConversacionId: String? = null,&#10;    viewModel: ChatViewModel = viewModel()&#10;) {&#10;&#10;    // ✅ FIX: Solo cargar conversación si hay un ID específico&#10;    // NO limpiar el chat si initialConversacionId es null (mantener conversación actual)&#10;    LaunchedEffect(initialConversacionId) {&#10;        Log.d(&quot;ChatScreen&quot;, &quot; LaunchedEffect triggered - initialConversacionId=$initialConversacionId&quot;)&#10;&#10;        if (initialConversacionId != null &amp;&amp; initialConversacionId.isNotBlank()) {&#10;            // Cargar conversación del historial&#10;            try {&#10;                Log.d(&quot;ChatScreen&quot;, &quot; Cargando conversación desde historial: id=$initialConversacionId&quot;)&#10;                viewModel.cargarConversacionPorId(initialConversacionId)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;ChatScreen&quot;, &quot;❌ Error cargando conversacion id=$initialConversacionId&quot;, e)&#10;            }&#10;        }&#10;        // ✅ Si initialConversacionId es null, NO hacer nada (mantener chat actual)&#10;        // Ya NO limpiamos el chat aquí&#10;    }&#10;&#10;    var drawerOpen by remember { mutableStateOf(false) }&#10;&#10;    // Asignar callbacks de navegación en cuanto la pantalla se crea (compatibilidad)&#10;    viewModel.navegarADocumentos = { navController.navigate(&quot;recursos&quot;) }&#10;    viewModel.navegarAActividades = { navController.navigate(&quot;calendario&quot;) }&#10;    viewModel.navegarAPerfil = { navController.navigate(&quot;perfil&quot;) }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background)&#10;    ) {&#10;        val listState = rememberLazyListState()&#10;&#10;        // Datos para controlar el scroll automático&#10;        val mensajes = viewModel.mensajes&#10;        val mensajesCount = mensajes.size&#10;        val ultimoMensajeClave = mensajes.lastOrNull()?.let { it.texto to it.esUsuario }&#10;        val mostrarSugerencias = viewModel.mostrarSugerencias.value&#10;&#10;        // Cuando cambia la lista (tamaño o contenido del último mensaje) o las sugerencias,&#10;        // hacer scroll suave al último ítem visible&#10;        LaunchedEffect(mensajesCount, ultimoMensajeClave, mostrarSugerencias) {&#10;            val extra = if (mostrarSugerencias) 1 else 0 // ítem de chips al final&#10;            val targetIndex = mensajesCount - 1 + extra&#10;            if (targetIndex &gt;= 0) {&#10;                listState.animateScrollToItem(targetIndex)&#10;            }&#10;        }&#10;&#10;        // HEADER&#10;        ChatHeader(&#10;            // Mostrar diálogo de confirmación antes de crear nuevo chat&#10;            onNewChat = {&#10;                // Si hay mensajes (más que el mensaje inicial), mostrar diálogo&#10;                if (viewModel.mensajes.size &gt; 1 || viewModel.conversacionId != null) {&#10;                    viewModel.mostrarDialogoNuevoChat.value = true&#10;                } else {&#10;                    // Si no hay conversación activa, iniciar la secuencia para nueva conversación&#10;                    viewModel.iniciarNuevaConversacion()&#10;                }&#10;            },&#10;            onMenuClick = { drawerOpen = true }&#10;        )&#10;&#10;        // LISTA DEL CHAT&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .weight(1f)&#10;                .padding(horizontal = 16.dp),&#10;            state = listState&#10;        ) {&#10;            items(viewModel.mensajes) { msg -&gt;&#10;                ChatBubble(msg) { mensaje -&gt;&#10;                    // Si la respuesta predefinida viene con una ruta, navegamos&#10;                    val route = mensaje.actionRoute&#10;                    if (!route.isNullOrBlank()) {&#10;                        try {&#10;                            Log.d(&quot;ChatAction&quot;, &quot;Attempting to navigate to route from message: $route&quot;)&#10;&#10;                            // Primero intentar la lambda del ViewModel (fallback seguro si hay otro NavController)&#10;                            when (route) {&#10;                                &quot;recursos&quot; -&gt; viewModel.navegarADocumentos?.invoke()&#10;                                &quot;actividades&quot; -&gt; viewModel.navegarAActividades?.invoke()&#10;                                &quot;perfil&quot; -&gt; viewModel.navegarAPerfil?.invoke()&#10;                            }&#10;&#10;                            // Luego intentar la navegación directa con navController (comportamiento estándar)&#10;                            navController.navigate(route) {&#10;                                launchSingleTop = true&#10;                                restoreState = true&#10;                            }&#10;                        } catch (ex: Exception) {&#10;                            Log.e(&quot;ChatAction&quot;, &quot;Navigation failed for route=$route&quot;, ex)&#10;                        }&#10;                    } else {&#10;                        // Si no hay route, ejecutamos la acción si existe&#10;                        mensaje.accion?.invoke()&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (viewModel.mostrarSugerencias.value) {&#10;                item {&#10;                    ChatChips(viewModel.sugerencias) {&#10;                        // Desde FAQ: NO ocultar sugerencias (usa default)&#10;                        viewModel.enviarMensaje(it)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // FOOTER DEL CHAT (DENTRO DE LA COLUMNA)&#10;        ChatInput {&#10;            // Desde input escrito: ocultar sugerencias&#10;            viewModel.enviarMensaje(it, ocultarSugerencias = true)&#10;        }&#10;    }&#10;&#10;    // MENÚ LATERAL&#10;    if (drawerOpen) {&#10;        Box(&#10;            modifier = Modifier.fillMaxSize()&#10;        ) {&#10;            Surface(&#10;                modifier = Modifier&#10;                    .width(300.dp)&#10;                    .fillMaxHeight()&#10;                    .align(Alignment.TopEnd),&#10;                color = Color.White,&#10;                shadowElevation = 12.dp&#10;            ) {&#10;                SideMenu(&#10;                    onNavigate = {&#10;                        drawerOpen = false&#10;                        navController.navigate(it)&#10;                    },&#10;                    onClose = { drawerOpen = false }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // DIÁLOGO DE CONFIRMACIÓN PARA NUEVO CHAT&#10;    if (viewModel.mostrarDialogoNuevoChat.value) {&#10;        AlertDialog(&#10;            onDismissRequest = { viewModel.mostrarDialogoNuevoChat.value = false },&#10;            title = { Text(&quot;Iniciar nuevo chat&quot;) },&#10;            text = { Text(&quot;Tu conversación actual se guardará automáticamente en el historial. ¿Deseas crear un nuevo chat?&quot;) },&#10;            confirmButton = {&#10;                TextButton(&#10;                    onClick = {&#10;                        viewModel.mostrarDialogoNuevoChat.value = false&#10;                        // Ejecutar secuencia que guarda/cierran la conversación y reinicia el chat&#10;                        viewModel.iniciarNuevaConversacion()&#10;                    }&#10;                ) {&#10;                    Text(&quot;Sí, crear nuevo&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { viewModel.mostrarDialogoNuevoChat.value = false }) {&#10;                    Text(&quot;Cancelar&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.chatbot_diseo.presentation.chat&#10;&#10;import android.util.Log&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.lazy.rememberLazyListState&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import com.example.chatbot_diseo.presentation.menu.SideMenu&#10;&#10;@Composable&#10;fun ChatScreen(&#10;    navController: NavHostController,&#10;    initialConversacionId: String? = null,&#10;    viewModel: ChatViewModel = viewModel()&#10;) {&#10;&#10;    // ✅ FIX: Solo cargar conversación si hay un ID específico&#10;    // NO limpiar el chat si initialConversacionId es null (mantener conversación actual)&#10;    LaunchedEffect(initialConversacionId) {&#10;        Log.d(&quot;ChatScreen&quot;, &quot; LaunchedEffect triggered - initialConversacionId=$initialConversacionId&quot;)&#10;&#10;        if (initialConversacionId != null &amp;&amp; initialConversacionId.isNotBlank()) {&#10;            // Cargar conversación del historial&#10;            try {&#10;                Log.d(&quot;ChatScreen&quot;, &quot; Cargando conversación desde historial: id=$initialConversacionId&quot;)&#10;                viewModel.cargarConversacionPorId(initialConversacionId)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;ChatScreen&quot;, &quot;❌ Error cargando conversacion id=$initialConversacionId&quot;, e)&#10;            }&#10;        }&#10;        // ✅ Si initialConversacionId es null, NO hacer nada (mantener chat actual)&#10;        // Ya NO limpiamos el chat aquí&#10;    }&#10;&#10;    var drawerOpen by remember { mutableStateOf(false) }&#10;&#10;    // Asignar callbacks de navegación en cuanto la pantalla se crea (compatibilidad)&#10;    viewModel.navegarADocumentos = { navController.navigate(&quot;recursos&quot;) }&#10;    viewModel.navegarAActividades = { navController.navigate(&quot;calendario&quot;) }&#10;    viewModel.navegarAPerfil = { navController.navigate(&quot;perfil&quot;) }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background)&#10;    ) {&#10;        val listState = rememberLazyListState()&#10;&#10;        // Datos para controlar el scroll automático&#10;        val mensajes = viewModel.mensajes&#10;        val mensajesCount = mensajes.size&#10;        val ultimoMensajeClave = mensajes.lastOrNull()?.let { it.texto to it.esUsuario }&#10;        val mostrarSugerencias = viewModel.mostrarSugerencias.value&#10;&#10;        // Cuando cambia la lista (tamaño o contenido del último mensaje) o las sugerencias,&#10;        // hacer scroll suave al último ítem visible&#10;        LaunchedEffect(mensajesCount, ultimoMensajeClave, mostrarSugerencias) {&#10;            val extra = if (mostrarSugerencias) 1 else 0 // ítem de chips al final&#10;            val targetIndex = mensajesCount - 1 + extra&#10;            if (targetIndex &gt;= 0) {&#10;                listState.animateScrollToItem(targetIndex)&#10;            }&#10;        }&#10;&#10;        // HEADER&#10;        ChatHeader(&#10;            // Mostrar diálogo de confirmación antes de crear nuevo chat&#10;            onNewChat = {&#10;                // Si hay mensajes (más que el mensaje inicial), mostrar diálogo&#10;                if (viewModel.mensajes.size &gt; 1 || viewModel.conversacionId != null) {&#10;                    viewModel.mostrarDialogoNuevoChat.value = true&#10;                } else {&#10;                    // Si no hay conversación activa, iniciar la secuencia para nueva conversación&#10;                    viewModel.iniciarNuevaConversacion()&#10;                }&#10;            },&#10;            onMenuClick = { drawerOpen = true }&#10;        )&#10;&#10;        // LISTA DEL CHAT&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .weight(1f)&#10;                .padding(horizontal = 16.dp),&#10;            state = listState&#10;        ) {&#10;            items(viewModel.mensajes) { msg -&gt;&#10;                ChatBubble(msg) { mensaje -&gt;&#10;                    // Si la respuesta predefinida viene con una ruta, navegamos&#10;                    val route = mensaje.actionRoute&#10;                    if (!route.isNullOrBlank()) {&#10;                        try {&#10;                            Log.d(&quot;ChatAction&quot;, &quot;Attempting to navigate to route from message: $route&quot;)&#10;&#10;                            // Primero intentar la lambda del ViewModel (fallback seguro si hay otro NavController)&#10;                            when (route) {&#10;                                &quot;recursos&quot; -&gt; viewModel.navegarADocumentos?.invoke()&#10;                                &quot;actividades&quot; -&gt; viewModel.navegarAActividades?.invoke()&#10;                                &quot;perfil&quot; -&gt; viewModel.navegarAPerfil?.invoke()&#10;                            }&#10;&#10;                            // Luego intentar la navegación directa con navController (comportamiento estándar)&#10;                            navController.navigate(route) {&#10;                                launchSingleTop = true&#10;                                restoreState = true&#10;                            }&#10;                        } catch (ex: Exception) {&#10;                            Log.e(&quot;ChatAction&quot;, &quot;Navigation failed for route=$route&quot;, ex)&#10;                        }&#10;                    } else {&#10;                        // Si no hay route, ejecutamos la acción si existe&#10;                        mensaje.accion?.invoke()&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (viewModel.mostrarSugerencias.value) {&#10;                item {&#10;                    ChatChips(viewModel.sugerencias) {&#10;                        // Desde FAQ: NO ocultar sugerencias (usa default)&#10;                        viewModel.enviarMensaje(it)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // FOOTER DEL CHAT (DENTRO DE LA COLUMNA)&#10;        ChatInput {&#10;            // Desde input escrito: ocultar sugerencias&#10;            viewModel.enviarMensaje(it, ocultarSugerencias = true)&#10;        }&#10;    }&#10;&#10;    // MENÚ LATERAL&#10;    if (drawerOpen) {&#10;        Box(&#10;            modifier = Modifier.fillMaxSize()&#10;        ) {&#10;            Surface(&#10;                modifier = Modifier&#10;                    .width(300.dp)&#10;                    .fillMaxHeight()&#10;                    .align(Alignment.TopEnd),&#10;                color = Color.White,&#10;                shadowElevation = 12.dp&#10;            ) {&#10;                SideMenu(&#10;                    onNavigate = { route -&gt;&#10;                        // ✅ FIX: Si la ruta es &quot;close&quot;, solo cerrar el menú sin navegar&#10;                        if (route == &quot;close&quot;) {&#10;                            drawerOpen = false&#10;                        } else {&#10;                            drawerOpen = false&#10;                            navController.navigate(route)&#10;                        }&#10;                    },&#10;                    onClose = { drawerOpen = false }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // DIÁLOGO DE CONFIRMACIÓN PARA NUEVO CHAT&#10;    if (viewModel.mostrarDialogoNuevoChat.value) {&#10;        AlertDialog(&#10;            onDismissRequest = { viewModel.mostrarDialogoNuevoChat.value = false },&#10;            title = { Text(&quot;Iniciar nuevo chat&quot;) },&#10;            text = { Text(&quot;Tu conversación actual se guardará automáticamente en el historial. ¿Deseas crear un nuevo chat?&quot;) },&#10;            confirmButton = {&#10;                TextButton(&#10;                    onClick = {&#10;                        viewModel.mostrarDialogoNuevoChat.value = false&#10;                        // Ejecutar secuencia que guarda/cierran la conversación y reinicia el chat&#10;                        viewModel.iniciarNuevaConversacion()&#10;                    }&#10;                ) {&#10;                    Text(&quot;Sí, crear nuevo&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { viewModel.mostrarDialogoNuevoChat.value = false }) {&#10;                    Text(&quot;Cancelar&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>